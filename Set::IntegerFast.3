

SET::INTEGERFAST(3)      PERL EXTENSIONS      SET::INTEGERFAST(3)


NAME
     Set::IntegerFast - Dynamic set creation and
                        efficient set operations

SYNOPSIS
     use Set::IntegerFast;

     Available methods (functions) and how to invoke (call)
     them:

     Fully qualified as functions:

     $ver = Set::IntegerFast::Version();
     $set = Set::IntegerFast::Create($elements);

     Set::IntegerFast::Destroy($set);
     Set::IntegerFast::Resize($set,$elements);
     Set::IntegerFast::Empty($set);
     Set::IntegerFast::Fill($set);
     Set::IntegerFast::Insert($set,$i);
     Set::IntegerFast::Delete($set,$i);
     Set::IntegerFast::in($set,$i);
     Set::IntegerFast::Union($set1,$set2,$set3);
     Set::IntegerFast::Intersection($set1,$set2,$set3);
     Set::IntegerFast::Difference($set1,$set2,$set3);
     Set::IntegerFast::ExclusiveOr($set1,$set2,$set3);
     Set::IntegerFast::Complement($set1,$set2);
     Set::IntegerFast::equal($set1,$set2);
     Set::IntegerFast::inclusion($set1,$set2);
     Set::IntegerFast::lexorder($set1,$set2);
     Set::IntegerFast::Compare($set1,$set2);
     Set::IntegerFast::Norm($set);
     Set::IntegerFast::Min($set);
     Set::IntegerFast::Max($set);
     Set::IntegerFast::Copy($set1,$set2);

     Object oriented:

     $set->Destroy;
     $set->Resize($elements);
     $set->Empty;
     $set->Fill;
     $set->Insert($i);
     $set->Delete($i);
     $set->in($i);
     $set1->Union($set2,$set3);
     $set1->Intersection($set2,$set3);
     $set1->Difference($set2,$set3);
     $set1->ExclusiveOr($set2,$set3);
     $set1->Complement($set2);
     $set1->equal($set2);
     $set1->inclusion($set2);
     $set1->lexorder($set2);
     $set1->Compare($set2);
     $set->Norm;
     $set->Min;
     $set->Max;
     $set1->Copy($set2);

     Brief description:

     Version       returns a version string
     Create        the set object constructor
     Destroy       free() the memory occupied by a set
     Resize        change the size of a set
     Empty         delete all elements in the set
     Fill          insert all possible elements into the set
     Insert        insert a given element
     Delete        delete a given element
     in            test the presence of a given element
     Union         calculate the union of two sets   (in-place is possible)
     Intersection  calculate the intersection of two sets            (idem)
     Difference    calculate the difference of two sets ("A\B")      (idem)
     ExclusiveOr   calculate the symmetric difference of two sets    (idem)
     Complement    calculate the complement of a set (in-place is possible)
     equal         test two sets for equality relation
     inclusion     test two sets for inclusion relation
     lexorder      test two sets for lexical order relation
     Compare       compare two sets - yields -1, 0 or 1 for <, = or >
     Norm          calculate the norm (number of elements) of the set
     Min           return the minimum of the set ( min{} = +infinity )
     Max           return the maximum of the set ( max{} = -infinity )
     Copy          copy one set to another

     Hint: method names all in lower case indicate a boolean return value!

DESCRIPTION
     =======================================
       $ver = Set::IntegerFast::Version();
     =======================================

     This function returns a string with the (numeric) version
     number of the "Set::IntegerFast" extension package.

     Since this function is not exported, you always have to fully
     qualify it explicitly (i.e., "Set::IntegerFast::...").

     This is to avoid possible conflicts with version functions
     from other packages.

     ===============================================
       $set = Set::IntegerFast::Create($elements);
     ===============================================

     This is the set object constructor method.

     Call this method to create a new set object able to contain
     "$elements" elements (all integers from zero to "$elements"
     minus one).

     The method returns a reference to the newly created set object.

     This reference is checked every time you pass it to one of the
     methods in this package if it's "blessed" (see the perlref(1),
     perlobj(1) and perlbot(1) man pages for more details on blessed
     references) into the right class (i.e., this package).

     This is because inheritance makes no sense for this implemen-
     tation of sets.

     (This is also the reason why the constructor doesn't follow
     the "$reference = new classname (parameters);" convention for
     object constructors)

     So DON'T rebless references stemming from this package to other
     classes (= packages)!

     If you need to have a set within another object, or if you want
     to expand the set object, rather embed a reference to the set
     in your object instead of using inheritance.

     Note that this method returns the value "undef" if you try to create
     a set object with zero elements. Any attempt to use this reference
     either results in a warning about the use of an uninitialized value
     (if the -w switch is set) or an error message with program abortion
     if you try to invoke a method with it.

     Note also that if you specify a negative number for "$elements" it
     will be interpreted as a large positive number due to its internal
     2's complement representation and the set object constructor method
     will attempt to create a set of that size, probably resulting in an
     "out of memory" error message and program abortion.

     ==================
       $set->Destroy;
     ==================

     This is the set object destructor method.

     You have to call this method explicitly in order to relinquish
     the memory occupied by a set object.

     If you lose the reference to your object (i.e., overwrite or
     undef the Perl variable containing the reference), the memory
     space of your set object will remain occupied but inaccessible
     through the rest of the lifetime of your Perl application.

     If you do this repeatedly, your application will use more and
     more memory and eventually fail with an "out of memory" error
     message.

     (For the technically interested: If the method was called
     "DESTROY" instead of "Destroy", it would be called automatically
     by Perl when the last reference to the object is deleted. Due
     to some misbehaviour in the Perl "malloc" routine, this always
     causes a "Bad free() ignored" warning message. Allegedly this
     warning doesn't show up if you build Perl without the Perl
     "malloc" but rather the "malloc" your system provides (i.e.,
     if you answer the question "use the malloc that comes with
     perl?" of the "Configure" script in the Perl distribution with
     "no"). I didn't test this, because I didn't want to go into the
     pains of rebuilding Perl.)

     Note that once you have called the destructor method, your Perl
     variable no longer contains a valid reference. In fact its value
     becomes "undef". Any attempt to use the contents of the variable
     either results in a warning about the use of an uninitialized
     value (if the -w switch is set) or an error message with program
     abortion if you try to invoke a method with it.

     ============================
       $set->Resize($elements);
     ============================

     This method allows you to change the size of an existing set,
     thereby preserving as many of the elements contained in it as
     will fit into the new set (i.e., all elements less than the
     minimum of the old and the new maximum number of elements).

     If the number of machine words needed to store the given maxi-
     mum number of elements of the new set is smaller than or equal
     to the number of words needed to store the old set, the memory
     already allocated to the old set is kept and simply adjusted to
     hold the new set.

     This means that even if the maximum number of elements increa-
     ses, this does not necessarily mean that new memory needs to
     be allocated (if the old and the new maximum number of ele-
     ments fit into the same number of machine words)!

     If the number of machine words needed to store the given maxi-
     mum number of elements of the new set is greater than the num-
     ber of words needed to store the old set, new memory is allo-
     cated for the new set, the old set is copied to the new one
     and the old set is deleted, i.e., the memory allocated to it
     is freed.

     THIS MEANS THAT THE POINTER (REFERENCE) STORED IN "$set" MAY NOT
     BE THE SAME AS BEFORE, INVALIDATING ANY COPIES OF THE OLD POINTER
     YOU MIGHT HAVE KEPT IN OTHER VARIABLES - BEWARE!!!

     It also means that if you decrease the size of a given set
     so that it will use fewer machine words, and increase it again
     later so that it will use more words than the downsized set but
     still less than the original set, new memory will be allocated
     anyway because the information about the size of the original
     set is lost when you downsize it.

     When the maximum number of elements is increased (regardless of
     wether the number of machine words used to store the new set
     increases or stays the same), the new elements are all initialized
     to zero, i.e., they are not contained in the new set.

     Beware that when you invert the meaning of contained/not contai-
     ned in your calculations (which you are free of doing, of course),
     i.e., when you are calculating the complement of the set you're
     actually interested in, increasing the size of your set might not
     yield the result you'd expect!

     I.e., doing this might not work as intended:

     $set = Set::IntegerFast::Create(1000);
     $set->Insert(0);
     $set->Insert(1);
     for ( $j = 4; $j <= $limit; $j += 2 ) { $set->Insert($j); }
     for ( $i = 3; ($j = $i * $i) <= $limit; $i += 2 )
     {
         for ( ; $j <= $limit; $j += $i ) { $set->Insert($j); }
     }
     $set->Resize(100000);

     This calculates the prime numbers up to 1000 and then increases
     the size of the set to 100000. However, since the original set
     contains all the NON-prime numbers, increasing the size of the
     set ends up with a mess: if an element below 1000 is not contai-
     ned in the set, it's a prime number, whereas all the numbers
     between 1000 and 100000 (which are not contained in the set
     due to the initialization of the new set) may or may not be
     prime numbers.

     If you calculate the set of primes instead and then increase the
     size of the set, there is no interpretation conflict:

     $set = Set::IntegerFast::Create(1000);
     $set->Fill;
     $set->Delete(0);
     $set->Delete(1);
     for ( $j = 4; $j <= $limit; $j += 2 ) { $set->Delete($j); }
     for ( $i = 3; ($j = $i * $i) <= $limit; $i += 2 )
     {
         for ( ; $j <= $limit; $j += $i ) { $set->Delete($j); }
     }
     $set->Resize(100000);

     In this case, all the elements which are contained in the new set
     definitely are prime numbers!

     Finally, note that "$set->Resize(0);" is (internally) exactly the
     same as "$set->Destroy;". (Remember Larry Wall: "There is more than
     one way to do it!")

     As with "Destroy", the contents of "$set" becomes "undef" by doing
     this (see the explanation of the "Destroy" method above for more
     details).

     ================
       $set->Empty;
     ================

     This method removes all elements the set contains from the set,
     leaving an empty set ("{}").

     The method "$set->in($i)" returns false (0) for every element
     after invoking this method for the given set.

     ===============
       $set->Fill;
     ===============

     This method adds all elements the set can potentially contain
     to the set, yielding a "full" set ("~{}" or the complement of
     the empty set).

     The method "$set->in($i)" returns true (1) for any element
     after invoking this method for the given set.

     =====================
       $set->Insert($i);
     =====================

     This method adds the element "$i" to the given set, i.e.,
     performs $set = $set + {$i} ("+" being the "union" operator
     for sets).

     If "$i" is outside of the range of zero to the maximum number
     "$elements" of elements the given set was created with minus
     one, an error message occurs.

     Note that negative indices "$i" will be interpreted as large
     positive numbers due to their internal 2's complement represen-
     tation and most likely lie outside the permitted range.

     =====================
       $set->Delete($i);
     =====================

     This method deletes the element "$i" from the given set, i.e.,
     performs $set = $set \ {$i} ("\" being the "difference"
     operator for sets).

     If "$i" is outside of the range of zero to the maximum number
     "$elements" of elements the given set was created with minus
     one, an error message occurs.

     Note that negative indices "$i" will be interpreted as large
     positive numbers due to their internal 2's complement represen-
     tation and most likely lie outside the permitted range.

     =================
       $set->in($i);
     =================

     This method tests if the element "$i" is contained in the given
     set.

     It returns true (1) if the given set contains element "$i" and
     false (0) otherwise.

     If "$i" is outside of the range of zero to the maximum number
     "$elements" of elements the given set was created with minus
     one, an error message occurs.

     Note that negative indices "$i" will be interpreted as large
     positive numbers due to their internal 2's complement represen-
     tation and most likely lie outside the permitted range.

     ==============================
       $set1->Union($set2,$set3);
     ==============================

     This method computes the union of the two argument sets (i.e.,
     "$set2 + $set3") and places the result into the set "$set1".

     The information that initially was stored in the resulting set
     "$set1" gets overwritten, i.e., lost.

     In-place substitution is possible, i.e., the resulting set may
     also be one (or both) of the two arguments.

     Note that the two argument sets and the resulting set must all
     have the same size (i.e., they must have been created with the
     same maximum number "$elements" of elements) or you will get
     an error message.

     =====================================
       $set1->Intersection($set2,$set3);
     =====================================

     This method computes the intersection of the two argument sets
     (i.e., "$set2 * $set3") and places the result into "$set1".

     The information that initially was stored in the resulting set
     "$set1" gets overwritten, i.e., lost.

     In-place substitution is possible, i.e., the resulting set may
     also be one (or both) of the two arguments.

     Note that the two argument sets and the resulting set must all
     have the same size (i.e., they must have been created with the
     same maximum number "$elements" of elements) or you will get
     an error message.

     ===================================
       $set1->Difference($set2,$set3);
     ===================================

     This method computes the difference of the two argument sets
     (i.e., "$set2 \ $set3") and places the result into "$set1".

     The information that initially was stored in the resulting set
     "$set1" gets overwritten, i.e., lost.

     In-place substitution is possible, i.e., the resulting set may
     also be one (or both) of the two arguments.

     Note that the two argument sets and the resulting set must all
     have the same size (i.e., they must have been created with the
     same maximum number "$elements" of elements) or you will get
     an error message.

     ===================================
       $set1->ExclusiveOr($set2,$set3);
     ===================================

     This method computes the symmetric difference of the two argu-
     ment sets, i.e., "( $set2 + $set3 ) \ ( $set2 * $set3 )", and
     places the result into "$set1".

     Note that the above formula is equivalent to calculating the
     exclusive-or of the corresponding elements in the two argument
     sets, hence the name of this method.

     Calculating the exclusive-or is much faster than evaluating the
     above formula because it uses an intrinsic processor operation.

     The information that initially was stored in the resulting set
     "$set1" gets overwritten, i.e., lost.

     In-place substitution is possible, i.e., the resulting set may
     also be one (or both) of the two arguments.

     Note that the two argument sets and the resulting set must all
     have the same size (i.e., they must have been created with the
     same maximum number "$elements" of elements) or you will get
     an error message.

     =============================
       $set1->Complement($set2);
     =============================

     This method computes the complement of the argument set
     (i.e., "~ $set2") and places the result into "$set1".

     The information that initially was stored in the resulting set
     "$set1" gets overwritten, i.e., lost.

     In-place substitution is possible, i.e., the resulting set
     may be the same as the argument.

     Note that the argument set and the resulting set must have
     the same size (i.e., they must have been created with the
     same maximum number "$elements" of elements) or you will
     get an error message.

     ========================
       $set1->equal($set2);
     ========================

     This method tests if the two sets "$set1" and "$set2" are the
     same.

     It returns true (1) if the given sets are the same and false (0)
     otherwise.

     Note that the two sets must have the same size (i.e., they must
     have been created with the same maximum number "$elements" of
     elements) or you will get an error message.

     ============================
       $set1->inclusion($set2);
     ============================

     This method tests if the set "$set1" is included in the set
     "$set2", i.e., if "$set1" is a subset of "$set2" (or in
     other terms, if "$set2" is a superset of "$set1").

     It returns true (1) if this condition is met and false (0)
     otherwise.

     Note that the two sets must have the same size (i.e., they must
     have been created with the same maximum number "$elements" of
     elements) or you will get an error message.

     ===========================
       $set1->lexorder($set2);
     ===========================

     This method compares two sets as though they were two strings of
     8-bit characters (signed or unsigned, depending on your system's
     default) and returns true (1) if "$set1" is less than or equal
     to "$set2", and false (0) otherwise.

     In some algorithms, it may be necessary to have many sets at the
     same time, and it may be important to define some order relation-
     ship on them to process them in a well-defined order.

     This lexical order is completely arbitrary and has no meaning
     whatsoever in terms of set theory.

     Note that the two sets must have the same size (i.e., they must
     have been created with the same maximum number "$elements" of
     elements) or you will get an error message.

     ==========================
       $set1->Compare($set2);
     ==========================

     This method compares two sets as though they were two strings of
     8-bit characters (signed or unsigned, depending on your system's
     default) and returns the value "-1" if "$set1" is less than
     "$set2", "0" if "$set1" and "$set2" are the same and "1"
     if "$set1" is greater than "$set2".

     In some algorithms, it may be necessary to have many sets at the
     same time, and it may be important to define some order relation-
     ship on them to process them in a well-defined order.

     This order is completely arbitrary and has no meaning whatsoever
     in terms of set theory.

     Note that the two sets must have the same size (i.e., they must
     have been created with the same maximum number "$elements" of
     elements) or you will get an error message.

     ===============
       $set->Norm;
     ===============

     This method computes the "norm", i.e., the number of elements the
     given set contains.

     Applied to the empty set (see also the method "Empty" above), this
     method returns zero.

     Applied to the "all" set (see also the method "Fill" above), this
     method returns the maximum number "$elements" of elements the set
     can hold (which the set was initially created with).

     ==============
       $set->Min;
     ==============

     This method computes the minimum of (i.e., the smallest element
     contained in) the given set.

     Note that the minimum of an empty set (see also the method "Empty"
     above) doesn't exist. Therefore, plus infinity (represented by the
     constant LONG_MAX on your system) is returned as the minimum of an
     empty set.

     The reason for this is that plus infinity is always greater than
     any minimum of any non-empty set, so that the minimum of the minima
     of several sets always yields a meaningful value.

     ==============
       $set->Max;
     ==============

     This method computes the maximum of (i.e., the greatest element
     contained in) the given set.

     Note that the maximum of an empty set (see also the method "Empty"
     above) doesn't exist. Therefore, minus infinity (represented by the
     constant LONG_MIN on your system) is returned as the maximum of an
     empty set.

     The reason for this is that minus infinity is always less than
     any maximum of any non-empty set, so that the maximum of the maxima
     of several sets always yields a meaningful value.

     =======================
       $set1->Copy($set2);
     =======================

     This method allows you to make a copy of a given set, for instance,
     to make possible the comparison between the initial and the final
     set after some computation.

     Note that the "carbon copy" set "$set1" is NOT created by the
     "Copy" method, that it rather must have been created beforehand,
     and that the two sets must have the same size (i.e., they must
     have been created with the same maximum number "$elements" of
     elements), or you will get an error message.

     The information that initially was stored in the set "$set1"
     gets overwritten, i.e., lost.

     Note also that one could substitute this method by the following
     two method invocations (other possibilities exist):

         $set0->Empty;
         $set1->Union($set2,$set0);

     provided that "$set0", "$set1" and "$set2" are all of the same size.

COMPLEXITY
     In the following, "n" is the maximum number of elements your set
     can hold, and "b" is the number of bits in a machine word on your
     system.

     (If the maximum number of elements you specified when creating the
     set is not a multiple of "b", set "n" to the next greater multiple
     of "b" here)

                             worst       best       average
                             case        case        case

        Create               n/b         n/b         n/b          1)
        Destroy              1           1           1
        Resize               n/b         1           n+b/2b       2)
        Empty                n/b         n/b         n/b
        Fill                 n/b         n/b         n/b
        Insert               1           1           1
        Delete               1           1           1
        in                   1           1           1
        Union                n/b         n/b         n/b
        Intersection         n/b         n/b         n/b
        Difference           n/b         n/b         n/b
        ExclusiveOr          n/b         n/b         n/b
        Complement           n/b         n/b         n/b
        equal                n/b         1           <<P1>>       3)
        inclusion            n/b         1           <<P2>>       3)
        lexorder             n/8         n/8         n/8          4)
        Compare              n/8         n/8         n/8          4)
        Norm                 n/b+n       n/b         <<P3>>       5)
        Min                  n/b+b       2           <<P4>>       6)
        Max                  n/b+b       2           <<P4>>       6)
        Copy                 n/b         n/b         n/b

     1) complexity is n/b here because a set is always initialized to
        an empty set (padded with zeros).
     2) "n" is the maximum number of elements in the NEW set here.
        "best case" is when the new set is smaller than the old set.
        "worst case" is when the new set is larger than the old one,
        in which case the new set has to be initialized and the old
        set has to be copied to the new one. "average case" assumes
        that half of the time the new set is larger, half of the time
        it is smaller than the old set.
     3) "best case" is when the condition is false at the first word.
     4) the two sets are compared one 8-bit character at a time.
     5) "worst case" is when the set is full, i.e., all elements are
        present. "best case" is when the set is empty.
     6) "best case" is when the first (Min) / the last (Max) element
        is set. "worst case" is when ONLY the last (Min) / the first
        (Max) element is set. (The algorithm has complexity n/b for
        a completely empty set)

     For sufficiently small values of "n", the average case complexity
     of the five methods equal, inclusion, Norm, Min and Max can be
     calculated with the following Perl subroutines (note the terms
     "2**$n" and even "2**(2*$n)" below which limit the computable
     complexities!) according to the formula:

          E[X]  =  SUM{ i=1..n } i * p(i)

     (where 1..n are the possible values the stochastic variable X can
     have, p(i) is the probability of value i and E[X] the average out-
     come of X)

     (The result is close to 1 for equal and inclusion, more or less
     close to n for Norm, and vaguely in the range n/2b to n/b for Min
     and Max)

     <<P1>> :

     sub average_case     # method "equal"
     {
         my($n,$b) = @_;
         my($i,$k,$t1,$t2,$sum);

         $k = int($n / $b);
         if (($k * $b) < $n) { $n = ++$k * $b; }
         $t1 = 0;
         $t2 = 0;
         $sum = 0;
         for ( $i = $k; $i >= 1; --$i )
         {
             $t1 = 2**(($k-$i+1)*$b);
             $sum += ($t1 - $t2) * $i;
             $t2 = $t1;
         }
         return($sum / 2**$n);
     }

     <<P2>> :

     sub average_case     # method "inclusion"
     {
         my($n,$b) = @_;
         my($i,$j,$k,$l,$s,$t1,$t2,$sum);

         $k = int($n / $b);
         if (($k * $b) < $n) { $n = ++$k * $b; }
         $t1 = 0;
         $t2 = 0;
         $sum = 0;
         for ( $i = $k; $i >= 1; --$i )
         {
             $s = 0;
             $l = ($i - 1) * $b;
             for ( $j = 0; $j <= $l; ++$j )
             {
                 $s += 2**$j * &binomial($l,$j);
             }
             $t1 = $s * 2**(2*($n-$l));
             $sum += ($t1 - $t2) * $i;
             $t2 = $t1;
         }
         return($sum / 2**(2*$n));
     }

     sub binomial
     {
         my($n,$k) = @_;
         my($prod) = 1;
         my($j) = 0;

         if (($n <= 0) || ($k <= 0) || ($n <= $k)) { return(1); }
         if ($k > $n - $k) { $k = $n - $k; }
         while ($j < $k)
         {
             $prod *= $n--;
             $prod /= ++$j;
         }
         return(int($prod + 0.5));
     }

     <<P3>> :

     sub average_case     # method "Norm"
     {
         my($n,$b) = @_;
         my($i,@j,$c,$k,$l,$p,$s,$sum);

         $k = int($n / $b);
         if (($k * $b) < $n) { $n = ++$k * $b; }
         $sum = 0;
         for ( $i = $k; $i >= 1; --$i )
         {
             $j[$i] = 0;
         }
         $c = 0;
         while (! $c)
         {
             $p = 1;
             $s = $k;
             for ( $i = $k; $i >= 1; --$i )
             {
                 $l = $j[$i];
                 $s += $l;
                 if ($l >= 1) { --$l; }
                 $p *= 2**$l;
             }
             $sum += $s * $p;
             $c = 1;
             for ( $i = $k; ($i >= 1) && $c; --$i )
             {
                 if ($c = (++$j[$i] > $b)) { $j[$i] = 0; }
             }
         }
         return($sum / 2**$n);
     }

     <<P4>> :

     sub average_case     # methods "Min" and "Max"
     {
         my($n,$b) = @_;
         my($i,$j,$k,$l,$o,$p,$sum);

         $k = int($n / $b);
         if (($k * $b) < $n) { $n = ++$k * $b; }
         $sum = $k;
         for ( $l = 2; $l <= ($k+$b); ++$l )
         {
             $o = $l - 2;
             if ($o > $k - 1) { $o = $k - 1; }
             $p = 0;
             for ( $i = 0; $i <= $o; ++$i )
             {
                 $j = $l - $i - 1;
                 if ($j <= $b)
                 {
                     $p += 2**($n-$i*$b-$j);
                 }
             }
             $sum += $l * $p;
         }
         return($sum / 2**$n);
     }

EXAMPLE
     #!perl -w

     use strict;
     no strict "vars";

     use Set::IntegerFast;

     print "\n***** Calculating Prime Numbers - The Seave Of Erathostenes *****\n";

     $limit = 0;

     if (-t STDIN)
     {
         while ($limit < 16)
         {
             print "\nPlease enter an upper limit (>15): ";
             $limit = <STDIN>;
             chop($limit) while ($limit =~ /\n$/);
             $limit = 0 if (($limit eq "") || ($limit =~ /\D/));
         }
         print "\n";
     }
     else
     {
         $limit = 100;
         print "\nRunning in batch mode - using $limit as upper limit.\n\n";
     }

     $set = Set::IntegerFast::Create($limit+1);

     $set->Fill;

     $set->Delete(0);
     $set->Delete(1);

     print "Calculating the prime numbers in the range [2..$limit]...\n\n";

     $start = time;

     for ( $j = 4; $j <= $limit; $j += 2 )
     {
         $set->Delete($j);
     }

     for ( $i = 3; ($j = $i * $i) <= $limit; $i += 2 )
     {
         for ( ; $j <= $limit; $j += $i )
         {
             $set->Delete($j);
         }
     }

     $stop = time;

     &print_elapsed_time;

     $min = $set->Min;
     $max = $set->Max;
     $norm = $set->Norm;

     print "Found $norm prime numbers in the range [2..$limit]:\n\n";

     for ( $i = $min, $j = 0; $i <= $max; $i++ )
     {
         if ($set->in($i))
         {
             print "prime number #", ++$j, " = $i\n";
         }
     }

     print "\n";

     $set->Destroy;

     exit;

     sub print_elapsed_time
     {
         ($sec,$min,$hour,$year,$yday) = (gmtime($stop - $start))[0,1,2,5,7];
         $year -= 70;
         $flag = 0;
         print "Elapsed time: ";
         if ($year > 0)
         {
             printf("%d year%s ", $year, ($year!=1)?"s":"");
             $flag = 1;
         }
         if (($yday > 0) || $flag)
         {
             printf("%d day%s ", $yday, ($yday!=1)?"s":"");
             $flag = 1;
         }
         if (($hour > 0) || $flag)
         {
             printf("%d hour%s ", $hour, ($hour!=1)?"s":"");
             $flag = 1;
         }
         if (($min > 0) || $flag)
         {
             printf("%d minute%s ", $min, ($min!=1)?"s":"");
         }
         printf("%d second%s.\n\n", $sec, ($sec!=1)?"s":"");
     }

     __END__

SEE ALSO
     perl(1), perlsub(1), perlmod(1), perlref(1), perlobj(1), perlbot(1),
     perlapi(1), perlguts(1).

VERSION
     This man page documents Set::IntegerFast, version 1.1.

AUTHOR
     Steffen Beyer <sb@sdm.de> (sd&m GmbH&Co.KG, Munich, Germany)

COPYRIGHT
     Copyright (c) 1995 by Steffen Beyer. All rights reserved.

LICENSE AGREEMENT
     This package is free software; you can redistribute it and/or
     modify it under the same terms as Perl itself.

